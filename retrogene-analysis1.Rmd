---
title: "Retrogene analysis"
author: "Johnathan Lo"
date: "2/1/2021"
output: pdf_document
---

```{r setup, include=FALSE, warning = FALSE, message= FALSE}
knitr::opts_chunk$set(echo = FALSE)
setwd("~/FALL20/Retrogenes")
load("1-17.RData") #complete dataset made on 1-17
load("32121.RData")
runs=1000 #set # runs for simulations and bootstraps
linkage_max <- 100000000
set.seed(6)
library(dplyr)
library(rentrez)
library(chromPlot)
library(GenomicFeatures)
library(ggplot2)
library(reshape2)

```

# 1. Human genome analysis

## a) Data Collection

Data is collected from http://yeti.amu.edu.pl/retrogenedb/ and http://www.regnetworkweb.org/home.jsp. Statistics for human genome size/chromosome size collected from NCBI. 


```{r, message = FALSE, results = 'hide', fig.keep = 'all'}
#human genome chromosome sizes in bp
human_genome <- data.frame(row.names = c(1:22, "X", "Y"), chrom.size = c(248956422,
                                                                         242193529,
                                                                         198295559,
                                                                         190214555,
                                                                         181538259,
                                                                         170805970,
                                                                         159345973,
                                                                         145138636,
                                                                         138394717,
                                                                         133797422,
                                                                         135086622,
                                                                         133275309,
                                                                         114364328,
                                                                         107043718,
                                                                         101991189,
                                                                         90338345,
                                                                         83257441,
                                                                         80373285,
                                                                         58617616,
                                                                         64444167,
                                                                         46709983,
                                                                         50818468,
                                                                         156040895,
                                                                         57227415))
#double the autosomes; this helps create a representative "area" for uniformly distributing random retrogene activity
human_genome[,1] <- human_genome[,1]*c(rep(2,22),1.5,1)

#next, a haploid version of the genome; to maintain a record and help calculate genetic distance
human_genome_h <- data.frame(row.names = c(1:22, "X", "Y"), chrom.size = c(248956422, 
                                                                         242193529,
                                                                         198295559,
                                                                         190214555,
                                                                         181538259,
                                                                         170805970,
                                                                         159345973,
                                                                         145138636,
                                                                         138394717,
                                                                         133797422,
                                                                         135086622,
                                                                         133275309,
                                                                         114364328,
                                                                         107043718,
                                                                         101991189,
                                                                         90338345,
                                                                         83257441,
                                                                         80373285,
                                                                         58617616,
                                                                         64444167,
                                                                         46709983,
                                                                         50818468,
                                                                         156040895,
                                                                         57227415))

#approximate genes per chromosome for humans
human_genes_per_chrom <- data.frame(row.names = c(1:22, "X", "Y"), chrom.size = c(3000,
                                                                                  2500,
                                                                                  1900,
                                                                                  1600,
                                                                                  1700,
                                                                                  1900,
                                                                                  1800,
                                                                                  1400,
                                                                                  1400,
                                                                                  1400,
                                                                                  2000,
                                                                                  1600,
                                                                                  800,
                                                                                  1200,
                                                                                  1200,
                                                                                  1300,
                                                                                  1600,
                                                                                  600,
                                                                                  1700,
                                                                                  900,
                                                                                  400,
                                                                                  800,
                                                                                  1400,
                                                                                  200))

#read in retrogene data
retrogenes <- read.csv("homo_sapiens_retrogene.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
parentals <- read.csv("homo_sapiens_parental.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
human_rec_map <- read.csv("human-recombination-map.csv")#kong et al
#assign to variables for convenience
parental_genes <- parentals$symbol
parental_ids <- parentals$external_id


#get GRN data
grns <- read.csv("human-grn/human.source", sep = "\t", header = FALSE, stringsAsFactors = FALSE)


#plot chrom data
data("hg_gap")
hg_gap
retrogenes$Colors <- "red"
retrogenes_plot <- retrogenes
retrogenes_plot$Chrom <- retrogenes_plot$chromosome
retrogenes_plot$Start <- retrogenes_plot$start
retrogenes_plot$End <- retrogenes_plot$end+300000
retrogenes_plot$Name <- retrogenes_plot$retrodb_id
retrogenes_plot <- retrogenes_plot[retrogenes_plot$Chrom %in% c(1:22, "X", "Y"),]
retrogenes_plot$Chrom <- paste("chr", retrogenes_plot$chromosome, sep = "")
retrogenes_plot <- retrogenes_plot[,c("Chrom", "Start", "End", "Name","Colors")]
chromPlot(gaps = hg_gap, bands = retrogenes_plot)

```


Next, organize data. We want to arrange the data into two datasets: 
1) Retrogenes as observations, each associated with corresponding parental gene and network partners
2) Parental genes as observations, each associated with corresponding retrogenes and network partners

In this way, each observation can be characterized as a variably-sized cluster or collection of genes. As such, these foundational datasets will be formed as lists of lists; each observation is itself a list of other associated genes. The key parameters that need to be included with each gene are:

a) ID
b) chromosome name
c) location on chromosome

```{r, message = FALSE, results = 'hide', fig.keep = 'all'}
#First, go through list of parental genes to find network partners
#use a list, because the number of partner genes per parental gene is variable
partners <- vector(mode = "list", length = length(parental_genes))
partners_ids <- vector(mode = "list", length = length(parental_genes))
for(i in 1:length(parental_genes)){
  partners[[i]] <- grns$V1[grns$V3 == parental_genes[i]]
  partners_ids[[i]] <- grns$V2[grns$V3 == parental_genes[i]]
}

#Next, parse out miRNA ids; these cannot be tracked through entrez
#Do this by removing IDs starting with "MI"
partners_ids_clean <-vector(mode = "list", length = length(partners_ids))
partners_clean <- vector(mode="list", length = length(partners_ids))
for(i in 1:length(partners_ids)){
  partners_ids_clean[[i]] <- partners_ids[[i]][!grepl("MI", partners_ids[[i]], fixed = TRUE)]
  partners_clean[[i]] <- partners[[i]][!grepl("MI", partners_ids[[i]], fixed = TRUE)]
}

#previous step resulted in empty indices; here we clean them out
empty_inds <- which(lapply(partners_clean, length)==0)
partners_ids_final <- partners_ids_clean[-empty_inds]
partners_final <- partners_clean[-empty_inds]
parentals_final <- parentals[-empty_inds,]
parental_genes_final <- parental_genes[-empty_inds]
parental_ids_final <- parental_ids[-empty_inds]
parental_chrom_final <- parentals_final$chromosome
parental_loc_final <- parentals_final$start

#Finally, we're ready to search NCBI for the remaining partner IDs. Uses rentrez package.
#For convenience, the below code is commented out and instead, we load from memory
# partners_records <- vector(mode = "list", length = length(partners_ids_final)) 
# for(i in 1:length(partners_ids_final)){
#   partners_records[[i]] <- vector(mode = "list", length = length(partners_ids_final[[i]]))
#   for(j in 1:length(partners_ids_final[[i]])){
#     try(partners_records[[i]][[j]] <- entrez_summary(db = "gene", id = partners_ids_final[[i]][j])) 
#   }
# }
load("partners_records.RData")

#We are ready to start building our final datasets.

#Here, we go through the list we retrieved from NCBI and extract genomic coordinates for each of the partner genes
partners_chrom <- vector(mode = "list", length = length(partners_records))
partners_chrom_loc <- vector(mode = "list", length = length(partners_records))
for(i in 1:length(partners_records)){
  partners_chrom[[i]] <- vector(mode = "character", length = length(partners_records[[i]]))
  partners_chrom_loc[[i]] <- vector(mode = "numeric", length = length(partners_records[[i]]))
  for(j in 1:length(partners_records[[i]])){
    partners_chrom[[i]][j] <- partners_records[[i]][[j]]$genomicinfo$chrloc
    partners_chrom_loc[[i]][j] <- partners_records[[i]][[j]]$genomicinfo$chrstart
  }
}

#Construct retrogenes_final - the dataset arranged by retrogenes
retrogenes_final <- vector(mode = "list", length = length(retrogenes))
for(i in 1:nrow(retrogenes)){
  indices <- grep(retrogenes$parental_accession[i], parental_ids_final)
  retrogenes_final[[i]] <- vector(mode = "list", length = length(indices))
  if(length(indices)>0){
    for(j in 1:length(indices)){
      ret_id <- retrogenes$retrodb_id[i]
      ret_chrom <- retrogenes$chromosome[i]
      ret_loc <- retrogenes$start[i]
      par_gene <- parental_genes_final[indices[j]]
      par_id <- parental_ids_final[indices[j]]
      par_chrom <- parental_chrom_final[indices[j]]
      par_loc <- parental_loc_final[indices[j]]
      part_genes <- partners_final[[indices[j]]]
      part_ids <- partners_ids_final[[indices[j]]]
      part_chroms <- partners_chrom[[indices[j]]]
      part_locs <- partners_chrom_loc[[indices[j]]]
      retrogenes_final[[i]][[j]] <- list(retroid = ret_id,
                                         retrochrom = ret_chrom,
                                         retroloc = ret_loc,
                                         parentalgene = par_gene,
                                         parentalid = par_id,
                                         parentalchrom = par_chrom,
                                         parentalloc = par_loc,
                                         partnergenes = part_genes,
                                         partnerids = part_ids,
                                         partnerchroms = part_chroms,
                                         partnerlocs = part_locs)
    }
  }
}
retrogenes_final <- retrogenes_final[lapply(retrogenes_final,length)!=0] #remove empty indices again; necessary because not every retrogene has a corresponding parental and/or partners in our miRNA removed dataset

#This is an exclusive list with just known protein coding retrogenes. 
retrogenes_pc <- retrogenes[retrogenes$status == "KNOWN_PROTEIN_CODING",]
retrogenes_final_pc <- list()
for(i in 1:length(retrogenes_final)){
  if(retrogenes_final[[i]][[1]]$retroid %in% retrogenes_pc$retrodb_id){
    retrogenes_final_pc <- c(retrogenes_final_pc, retrogenes_final[i])
  }
}


#Now, construct second dataset - organized by parental genes
retrogenes_by_parentals <- vector(mode = "list", length = length(parental_genes_final))
for(i in 1:length(parental_genes_final)){
  indices <- grep(parental_ids_final[[i]], retrogenes$parental_accession)
  par_gene <- parental_genes_final[i]
  par_id <- parental_ids_final[i]
  par_chrom <- parental_chrom_final[i]
  par_loc <- parental_loc_final[i]
  part_genes <- partners_final[[i]]
  part_ids <- partners_ids_final[[i]]
  part_chroms <- partners_chrom[[i]]
  part_locs <- partners_chrom_loc[[i]]
  retro_ids <- retrogenes[indices,]$retrodb_id
  retro_chroms <- retrogenes[indices,]$chromosome
  retro_locs <- retrogenes[indices,]$start
  
  retrogenes_by_parentals[[i]] <- list(retroid = retro_ids,
                                       retrochrom = retro_chroms,
                                       retroloc = retro_locs,
                                       parentalgene = par_gene,
                                       parentalid = par_id,
                                       parentalchrom = par_chrom,
                                       parentalloc = par_loc,
                                       partnergenes = part_genes,
                                       partnerids = part_ids,
                                       partnerchroms = part_chroms,
                                       partnerlocs = part_locs)
}
#Again, make a subset of just those parental genes producing protein coding retrogenes
retrogenes_by_parentals_pc <- vector(mode = "list", length = length(parental_genes_final))
for(i in 1:length(parental_genes_final)){
  indices <- grep(parental_ids_final[[i]], retrogenes_pc$parental_accession)
  if(length(indices)>0){
    par_gene <- parental_genes_final[i]
    par_id <- parental_ids_final[i]
    par_chrom <- parental_chrom_final[i]
    par_loc <- parental_loc_final[i]
    part_genes <- partners_final[[i]]
    part_ids <- partners_ids_final[[i]]
    part_chroms <- partners_chrom[[i]]
    part_locs <- partners_chrom_loc[[i]]
    retro_ids <- retrogenes_pc[indices,]$retrodb_id
    retro_chroms <- retrogenes_pc[indices,]$chromosome
    retro_locs <- retrogenes_pc[indices,]$start
    
    retrogenes_by_parentals_pc[[i]] <- list(retroid = retro_ids,
                                            retrochrom = retro_chroms,
                                            retroloc = retro_locs,
                                            parentalgene = par_gene,
                                            parentalid = par_id,
                                            parentalchrom = par_chrom,
                                            parentalloc = par_loc,
                                            partnergenes = part_genes,
                                            partnerids = part_ids,
                                            partnerchroms = part_chroms,
                                            partnerlocs = part_locs)
  }
}
retrogenes_by_parentals_pc <- retrogenes_by_parentals_pc[-which(sapply(retrogenes_by_parentals_pc, is.null))]

find_dist <- function(chr, loc1, loc2){
  if(chr %in% c("X", "Y")){
    chr = "23"
  }
  rec_chrom <- human_rec_map[human_rec_map$chr == chr, ]
  loc1_match <- human_rec_map[which.min(abs(loc1 - rec_chrom$phys.loc)),] 
  loc2_match <- human_rec_map[which.min(abs(loc2 - rec_chrom$phys.loc)),]
  rec_dist <- as.numeric(abs(loc1_match$gen.loc - loc2_match$gen.loc))
  return(rec_dist)
}

#total number of partner genes
all_partners <- c()
for(i in 1:length(retrogenes_final)){
  partners_i <- retrogenes_final[[i]][[1]]$partnergenes
  all_partners <- c(all_partners, partners_i)
}
length(unique(all_partners))
#Here are the final datasets:
# head(retrogenes_final)
# head(retrogenes_final_pc)
# head(retrogenes_by_parentals)
# head(retrogenes_by_parentals_pc)
```

## c) Exploratory Data Analysis

One aspect of this data that could be interesting to look at is the distribution of the number of retrogenes generated by each of the parental genes in our dataset. Do some parental genes generate more retrogenes than others? Is this distribution symmetric or skewed? Are there differences between the parental genes of protein coding retrogenes and the parental genes of full set of retrogenes?

```{r, message = FALSE, results = 'hide', fig.keep = 'all'}
#for full set of retrogenes
num_ret_per_par <- vector(mode = "numeric", length = length(retrogenes_by_parentals))
for(i in 1:length(retrogenes_by_parentals)){
  num_ret_per_par[i] <- length(retrogenes_by_parentals[[i]]$retroid)
}
num_ret_per_par <- data.frame(num_rets =  num_ret_per_par)
ggplot(num_ret_per_par, aes(x=num_rets)) + 
  geom_histogram(binwidth = 1) +
  labs(title = "Number of retrogenes per parental gene", x = "Number of retrogenes", y = "Count") +
  geom_text(x = 25, y = 600, 
            label = paste("Median: ", median(num_ret_per_par$num_rets)), hjust = 0) + 
  geom_text(x = 25, y = 400, 
            label = paste("Mean: ", mean(num_ret_per_par$num_rets)), hjust = 0)

#for protein coding retrogenes
num_ret_per_par_pc <- vector(mode = "numeric", length = length(retrogenes_by_parentals_pc))
for(i in 1:length(retrogenes_by_parentals_pc)){
  num_ret_per_par_pc[i] <- length(retrogenes_by_parentals_pc[[i]]$retroid)
}
num_ret_per_par_pc <- data.frame(num_rets = num_ret_per_par_pc)
ggplot(num_ret_per_par_pc, aes(x=factor(num_rets))) + 
  geom_histogram(stat = "count") +
  labs(title = "Number of protein coding retrogenes per eligible parental gene", x = "Number of protein-coding retrogenes", y = "Count") +
  geom_text(x = 2, y = 40, 
            label = paste("Median: ", median(num_ret_per_par_pc$num_rets)), hjust = 0) + 
  geom_text(x = 2, y = 20, 
            label = paste("Mean: ", mean(num_ret_per_par_pc$num_rets)), hjust = 0)  +
  scale_x_discrete()

```

We can also revisit the chromosome plots, this time looking at the distribution of parental genes across the genome as well as protein coding retrogenes only.

```{r, message = FALSE, results = 'hide', fig.keep = 'all'}
parental_genes_names <- vector(mode = "character", length = length(retrogenes_by_parentals))
parental_genes_chrom <- vector(mode = "character", length = length(retrogenes_by_parentals))
parental_genes_start <- vector(mode = "numeric", length = length(retrogenes_by_parentals))
parental_genes_end <- vector(mode = "numeric", length = length(retrogenes_by_parentals))
for(i in 1:length(retrogenes_by_parentals)){
  parental_genes_names[i] <- retrogenes_by_parentals[[i]]$parentalid
  parental_genes_chrom[i] <- retrogenes_by_parentals[[i]]$parentalchrom
  parental_genes_start[i] <- retrogenes_by_parentals[[i]]$parentalloc 
  parental_genes_end[i] <- retrogenes_by_parentals[[i]]$parentalloc+300000
}
parental_genes_chromplot <- data.frame(Name = parental_genes_names,
                                       Chrom = parental_genes_chrom,
                                       Start = parental_genes_start,
                                       End = parental_genes_end,
                                       Colors = rep("blue", times = length(retrogenes_by_parentals)))
chromPlot(gaps = hg_gap, segment = parental_genes_chromplot, title = "Parental genes") 

##protein coding retrogenes only
pc_genes_names <- vector(mode = "character", length = length(retrogenes_final_pc))
pc_genes_chrom <- vector(mode = "character", length = length(retrogenes_final_pc))
pc_genes_start <- vector(mode = "numeric", length = length(retrogenes_final_pc))
pc_genes_end <- vector(mode = "numeric", length = length(retrogenes_final_pc))
for(i in 1:length(retrogenes_final_pc)){
  pc_genes_names[i] <- retrogenes_final_pc[[i]][[1]]$retroid
  pc_genes_chrom[i] <- retrogenes_final_pc[[i]][[1]]$retrochrom
  pc_genes_start[i] <- retrogenes_final_pc[[i]][[1]]$retroloc
  pc_genes_end[i] <- retrogenes_final_pc[[i]][[1]]$retroloc+900000
}
pc_genes_chromplot <- data.frame(Name = pc_genes_names,
                                 Chrom = pc_genes_chrom,
                                 Start = pc_genes_start,
                                 End = pc_genes_end,
                                 Colors = rep("purple", times = length(retrogenes_final_pc)))
chromPlot(gaps = hg_gap, segment = pc_genes_chromplot, title = "Protein-coding retrogenes")

```

Finally, we can examine the distribution of the network genes in the same way as above.

```{r, message = FALSE, results = 'hide', fig.keep = 'all'}
num_network <- 0
for(i in 1:length(retrogenes_by_parentals)){
  num_network <- num_network + length(retrogenes_by_parentals[[i]]$partnergenes)
}
network_genes_names <- vector(mode = "character", length = num_network)
network_genes_chrom <- vector(mode = "character", length = num_network)
network_genes_start <- vector(mode = "numeric", length = num_network)
network_genes_end <- vector(mode = "numeric", length = num_network)
count <- 0
for(i in 1:length(retrogenes_by_parentals)){
  num <- length(retrogenes_by_parentals[[i]]$partnergenes)
  for(j in 1:num){
    network_genes_names[count + j] <- retrogenes_by_parentals[[i]]$partnergenes[j]
    network_genes_chrom[count + j] <- retrogenes_by_parentals[[i]]$partnerchroms[j]
    network_genes_start[count + j] <- retrogenes_by_parentals[[i]]$partnerlocs[j]
    network_genes_end[count + j] <- retrogenes_by_parentals[[i]]$partnerlocs[j] + 100000
  }
  count <- count + num
}

network_genes_chromplot <- data.frame(Name = network_genes_names,
                                      Chrom = network_genes_chrom,
                                      Start = network_genes_start,
                                      End = network_genes_end,
                                      Colors = rep("orange", times = length(num_network)))
chromPlot(gaps = hg_gap, segment = network_genes_chromplot, title = "Partner genes") 

#network genes of protein coding retrogenes only
num_network_pc <- 0
for(i in 1:length(retrogenes_by_parentals_pc)){
  num_network_pc <- num_network_pc + length(retrogenes_by_parentals_pc[[i]]$partnergenes)
}
network_pc_genes_names <- vector(mode = "character", length = num_network_pc)
network_pc_genes_chrom <- vector(mode = "character", length = num_network_pc)
network_pc_genes_start <- vector(mode = "numeric", length = num_network_pc)
network_pc_genes_end <- vector(mode = "numeric", length = num_network_pc)
count <- 0
for(i in 1:length(retrogenes_by_parentals_pc)){
  num <- length(retrogenes_by_parentals_pc[[i]]$partnergenes)
  for(j in 1:num){
    network_pc_genes_names[count + j] <- retrogenes_by_parentals_pc[[i]]$partnergenes[j]
    network_pc_genes_chrom[count + j] <- retrogenes_by_parentals_pc[[i]]$partnerchroms[j]
    network_pc_genes_start[count + j] <- retrogenes_by_parentals_pc[[i]]$partnerlocs[j]
    network_pc_genes_end[count + j] <- retrogenes_by_parentals_pc[[i]]$partnerlocs[j] + 100000
  }
  count <- count + num
}

network_pc_genes_chromplot <- data.frame(Name = network_pc_genes_names,
                                      Chrom = network_pc_genes_chrom,
                                      Start = network_pc_genes_start,
                                      End = network_pc_genes_end,
                                      Colors = rep("orange", times = length(num_network_pc)))
chromPlot(gaps = hg_gap, segment = network_pc_genes_chromplot, title = "Partner genes") 
```



# 2. Testing data quality

We want to confirm whether or not our data collection procedures have produced plausible and correct data. To do this, we test an existing and well-studied hypothesis; the out-of-the-X (ootX) hypothesis. This hypothesis states that in human and drosophila, more retrogenes originate from the X chromosome than expected given a uniformly random chance of retrogene formation from any gene in the genome. This hypothesis has abundant empirical support, and so we can use it to test our data quality.

## a) Building reference distributions

The null hypothesis is that every gene on every chromosome is equally likely to produce retrogenes. Thus, we build the reference distribution by drawing chromosomes weighted by the number of genes per chromosome. We can build one reference distribution for the set of all retrogenes and another for the set of only protein coding retrogenes.

```{r, eval = FALSE}
#build reference distribution for set of all retrogenes
ref_dist_full_2a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  sim_parents <- sample(c(1:22, "X", "Y"), 
                        size = length(retrogenes_final), 
                        prob = human_genes_per_chrom$chrom.size,
                        replace = TRUE)
  ref_dist_full_2a[i] <- sum(sim_parents == "X")
}
density_full_2a <- density(ref_dist_full_2a)

#build reference distribution for set of just protein coding retrogenes
ref_dist_pc_2a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  sim_parents <- sample(c(1:22, "X", "Y"), 
                        size = length(retrogenes_final_pc), 
                        prob = human_genes_per_chrom$chrom.size,
                        replace = TRUE)
  ref_dist_pc_2a[i] <- sum(sim_parents == "X")
}
density_pc_2a <- density(ref_dist_pc_2a)

#take a look at reference distributions
ref_dist_2a_df <- data.frame(num_diff_full = ref_dist_full_2a, num_diff_pc = ref_dist_pc_2a)
ggplot(ref_dist_2a_df, aes(x = num_diff_full)) + 
  geom_histogram(aes(y =..density..), 
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue") +
  geom_density( alpha = .6, color = "darkblue", size = 1, fill = "lightblue") +
  geom_vline(aes(xintercept = mean(num_diff_full), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of parental genes from the X (Full)", 
       x = "Number of parental genes from the X chromosome", 
       y = "Density") + 
  theme_classic() +
  theme(legend.position = "none")

ggplot(ref_dist_2a_df, aes(x = num_diff_pc)) + 
  geom_bar(
            position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = mean(num_diff_pc), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of parental genes from the X (Protein coding only)", 
       x = "Number of parental genes from the X chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none")

#chrom 2
ref_dist_full_22a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  sim_parents <- sample(c(1:22, "X", "Y"), 
                        size = length(retrogenes_final), 
                        prob = human_genes_per_chrom$chrom.size,
                        replace = TRUE)
  ref_dist_full_22a[i] <- sum(sim_parents == "2")
}
density_full_22a <- density(ref_dist_full_22a)

#build reference distribution for set of just protein coding retrogenes
ref_dist_pc_22a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  sim_parents <- sample(c(1:22, "X", "Y"), 
                        size = length(retrogenes_final_pc), 
                        prob = human_genes_per_chrom$chrom.size,
                        replace = TRUE)
  ref_dist_pc_22a[i] <- sum(sim_parents == "2")
}
density_pc_22a <- density(ref_dist_pc_22a)

#take a look at reference distributions
ref_dist_22a_df <- data.frame(num_diff_full = ref_dist_full_22a, num_diff_pc = ref_dist_pc_22a)
ggplot(ref_dist_22a_df, aes(x = num_diff_full)) + 
  geom_histogram(aes(y =..density..), 
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue") +
  geom_density( alpha = .6, color = "darkblue", size = 1, fill = "lightblue") +
  geom_vline(aes(xintercept = mean(num_diff_full), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of parental genes from the 2 (Full)", 
       x = "Number of parental genes from the 2 chromosome", 
       y = "Density") + 
  theme_classic() +
  theme(legend.position = "none")

ggplot(ref_dist_22a_df, aes(x = num_diff_pc)) + 
  geom_bar(
            position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = mean(num_diff_pc), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of parental genes from the 2 (Protein coding only)", 
       x = "Number of parental genes from the 2 chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none")
```

## b) Obtaining test statistics

Our test statistic will be the total number of retrogenes that do originate off the X. We can calculate this for both the full set and the protein coding set.

```{r}
#full set test statistic
totalX_2b <- 0
for(i in 1:length(retrogenes_final)){
  if(retrogenes_final[[i]][[1]]$parentalchrom == "X"){
    totalX_2b <- totalX_2b + 1
  }
}

totalX_pc_2b <- 0
for(i in 1:length(retrogenes_final_pc)){
  if(retrogenes_final_pc[[i]][[1]]$parentalchrom == "X"){
    totalX_pc_2b <- totalX_pc_2b +1
  }
}

#full set test statistic for chrom 2
totalX_22b <- 0
for(i in 1:length(retrogenes_final)){
  if(retrogenes_final[[i]][[1]]$parentalchrom == "2"){
    totalX_22b <- totalX_22b + 1
  }
}

totalX_pc_22b <- 0
for(i in 1:length(retrogenes_final_pc)){
  if(retrogenes_final_pc[[i]][[1]]$parentalchrom == "2"){
    totalX_pc_22b <- totalX_pc_22b +1
  }
}
```


## c) Hypothesis testing

Now we can test our observed statistics against our reference distributions. We will use a significance level of \(\alpha = .01\)

```{r}
p_val_full_2c <- sum(ref_dist_full_2a <= totalX_2b)/runs * 2
p_val_pc_2c <- sum(ref_dist_pc_2a>= totalX_pc_2b)/runs * 2

# plot(density_full_2a, 
#      ylim=c(-.005,.035), 
#      main = "Full set test", 
#      xlab = "total X count", 
#      ylab = "density",
#      col = 6 )
# polygon(density(ref_dist_full_2a),
#         col = rgb(0,0,1,.2))
# lines(c(totalX_2b, totalX_2b),c(-0.05, .035), lwd = 3, col = "blue")
# text(210, .025, paste("p = ",p_val_full_2c), pos = 4, cex = 1)
# 
# plot(density_pc_2a, 
#      ylim=c(-.005,.25),
#      xlim = c(0, 25),
#      main = "protein coding only", 
#      xlab = "total X count", 
#      ylab = "density",
#      col = 9 )
# polygon(density(ref_dist_pc_2a),
#         col = rgb(0,.6,.4,.2))
# lines(c(totalX_pc_2b, totalX_pc_2b),c(-0.05, .25), lwd = 3, col = "blue")
# text(15, .2, paste("p ~ ",p_val_pc_2c), pos = 4, cex = 1)

ggplot(ref_dist_2a_df, aes(x = num_diff_full)) + 
  geom_histogram(aes(y =..density..), 
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue") +
  geom_density( alpha = .6, color = "darkblue", size = 1, fill = "lightblue") +
  geom_vline(aes(xintercept = totalX_2b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe more retrogenes out of the X than expected? (Full)", 
       x = "Number of parental genes from the X chromosome", 
       y = "Density") + 
  theme_classic() +
  theme(legend.position = "none") + 
  geom_text(x = 150, y = .02,
            label = paste("p = ", p_val_full_2c))

ggplot(ref_dist_2a_df, aes(x = num_diff_pc)) + 
  geom_bar(position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = totalX_pc_2b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe more retrogenes out of the X than expected? (Protein coding only)", 
       x = "Number of parental genes from the X chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") +
  geom_text(x = 15, y = 150,
            label = paste("p = ", p_val_pc_2c))

#for chrom 2
p_val_full_22c <- sum(ref_dist_full_22a >= totalX_22b)/runs
p_val_pc_22c <- sum(ref_dist_pc_22a>=totalX_pc_22b)/runs

# plot(density_full_2a, 
#      ylim=c(-.005,.035), 
#      main = "Full set test", 
#      xlab = "total X count", 
#      ylab = "density",
#      col = 6 )
# polygon(density(ref_dist_full_2a),
#         col = rgb(0,0,1,.2))
# lines(c(totalX_2b, totalX_2b),c(-0.05, .035), lwd = 3, col = "blue")
# text(210, .025, paste("p = ",p_val_full_2c), pos = 4, cex = 1)
# 
# plot(density_pc_2a, 
#      ylim=c(-.005,.25),
#      xlim = c(0, 25),
#      main = "protein coding only", 
#      xlab = "total X count", 
#      ylab = "density",
#      col = 9 )
# polygon(density(ref_dist_pc_2a),
#         col = rgb(0,.6,.4,.2))
# lines(c(totalX_pc_2b, totalX_pc_2b),c(-0.05, .25), lwd = 3, col = "blue")
# text(15, .2, paste("p ~ ",p_val_pc_2c), pos = 4, cex = 1)

ggplot(ref_dist_22a_df, aes(x = num_diff_full)) + 
  geom_histogram(
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue")  +
  geom_vline(aes(xintercept = totalX_22b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe more retrocopies out of chromosome 2 than expected?", 
       x = "Number of parental genes from chromosome 2", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") + 
  geom_text(x = 300, y = 80,
            label = paste("p = ", p_val_full_22c))

ggplot(ref_dist_22a_df, aes(x = num_diff_pc)) + 
  geom_bar(position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = totalX_pc_22b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe more retrogenes out of chromosome 2 than expected?", 
       x = "Number of parental genes from chromosome 2", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") +
  geom_text(x = 15, y = 150,
            label = paste("p = ", p_val_pc_22c))
```


These test results clearly support the ootX hypothesis. We can be somewhat confident in the quality of our data, although there are other avenues if extensive quality control is needed.


# 3. First hypothesis test: retrogenes are not distributed across the genome independent of parental location

We hypothesize that differences in linkage can influence retrogene fixation probability. This difference in linkage can be either an increase or decrease in linkage. Hence, we conduct a 2-tailed test.

## a) Building the reference distribution

Here, we build the reference distribution. Our null hypothesis is that retrogenes are distributed across the genome at random. Hence, we will randomly select a set of parental genes by sampling from the set of chromosomes weighted by gene density, and then create daughter retrogenes by sampling from the set of chromosomes weighted by size in base pairs. The statistic we will construct a distribution over is \(\gamma = \frac{total\;pairs\;on\;different\;chromosomes}{total\;observations}\). By normalizing to a percentage, we can better compare results from the full set of retrogenes to results from the protein coding retrogenes only. 

```{r, eval = FALSE}
#make reference distribution for full set of retrogenes
ref_dist_full_3a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  diff_chrom_bs <- vector(mode = "logical", length = length(retrogenes_final))
  #retro_sample <- sample(retrogenes_final, size = length(retrogenes_final), replace = TRUE)
  for(j in 1:length(retrogenes_final)){
    retro_chrom <- sample(row.names(human_genome), size = 1, prob = human_genome$chrom.size)#try with gene density
    #parent_chrom <- retro_sample[[j]][[1]]$parentalchrom
    parent_chrom <- sample(row.names(human_genome), size = 1, prob = human_genes_per_chrom$chrom.size)
    diff_chrom_bs[j] <- retro_chrom!=parent_chrom
  }
  ref_dist_full_3a[i] <- sum(diff_chrom_bs)/length(retrogenes_final)
}
density_full_3a <- density(ref_dist_full_3a)

#make reference distribution for protein coding set
ref_dist_pc_3a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  diff_chrom_bs <- vector(mode = "logical", length = length(retrogenes_final_pc))
  #retro_sample <- sample(retrogenes_final_pc, size = length(retrogenes_final_pc), replace = TRUE)
  for(j in 1:length(retrogenes_final_pc)){
    retro_chrom <- sample(row.names(human_genome), size = 1, prob = human_genome$chrom.size)
    #parent_chrom <- retro_sample[[j]][[1]]$parentalchrom
    parent_chrom <- sample(row.names(human_genome), size = 1, prob = human_genes_per_chrom$chrom.size)
    diff_chrom_bs[j] <- retro_chrom!=parent_chrom 
  }
  ref_dist_pc_3a[i] <- sum(diff_chrom_bs)/length(retrogenes_final_pc)
}
density_pc_3a <- density(ref_dist_pc_3a)

#visualize
ref_dist_3a_df <- data.frame(num_diff_full = ref_dist_full_3a, num_diff_pc = ref_dist_pc_3a)
ggplot(ref_dist_3a_df, aes(x = num_diff_full)) + 
  geom_histogram(aes(y =..density..), 
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue") +
  geom_density( alpha = .6, color = "darkblue", size = 1, fill = "lightblue") +
  geom_vline(aes(xintercept = mean(num_diff_full), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of movement away from the parental chromosome (Full)", 
       x = "Average proportion of genes moving away from parental chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none")

ggplot(ref_dist_3a_df, aes(x = num_diff_pc)) + 
  geom_histogram(aes(y = ..density..),
                position = "identity", 
                alpha = .5, color = "darkgreen", 
                fill = "lightgreen") +
  geom_density(alpha = .6, color = "darkgreen", size = 1, fill = "lightgreen") + 
  geom_vline(aes(xintercept = mean(num_diff_pc), color = "orange"), linetype = "dashed")+
  labs(title = "Sampling distribution of movement away from the parental chromosome (Protein coding only)", 
       x = "Average proportion of genes moving away from parental chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none")
```


## b) Calculate test statistics

For our test statistics, we want to calculate the statistic we invented above using our sample data.
```{r}
#for our full dataset
diff_chrom_full_3b <- vector(mode = "logical", length = length(retrogenes_final))
for(i in 1:length(retrogenes_final)){
  retro_chrom <- retrogenes_final[[i]][[1]]$retrochrom
  parent_chrom <- retrogenes_final[[i]][[1]]$parentalchrom
  diff_chrom_full_3b[i] <- retro_chrom!=parent_chrom
}
ts_full_3b <- sum(diff_chrom_full_3b)/length(retrogenes_final)

#for protein coding only
diff_chrom_pc_3b <- vector(mode = "logical", length = length(retrogenes_final_pc))
for(i in 1:length(retrogenes_final_pc)){
  retro_chrom <- retrogenes_final_pc[[i]][[1]]$retrochrom
  parent_chrom <- retrogenes_final_pc[[i]][[1]]$parentalchrom
  diff_chrom_pc_3b[i] <- retro_chrom!=parent_chrom
}
ts_pc_3b <- sum(diff_chrom_pc_3b)/length(retrogenes_final_pc)

#no x
noX_indices <- c()
for(i in 1:length(retrogenes_final_pc)){
  if(retrogenes_final_pc[[i]][[1]]$parentalchrom == "X"){
    noX_indices <- c(noX_indices, i)
  }
}
retrogenes_final_pc_noX <- retrogenes_final_pc[-noX_indices]
diff_chrom_pc_noX_3b <- vector(mode = "logical", length = length(retrogenes_final_pc_noX))
for(i in 1:length(retrogenes_final_pc_noX)){
  retro_chrom <- retrogenes_final_pc_noX[[i]][[1]]$retrochrom
  parent_chrom <- retrogenes_final_pc_noX[[i]][[1]]$parentalchrom
  diff_chrom_pc_noX_3b[i] <- retro_chrom!=parent_chrom
}
ts_pc_noX_3b <- sum(diff_chrom_pc_noX_3b)/length(retrogenes_final_pc_noX)
```

## c) Test hypotheses

With our test statistics, we can test our hypotheses. This will be a two tailed test at \(\alpha = .01\). Since our test is non-parametric, this equates to testing both sides at \(.005\)

```{r}
pval_full_3c <- sum(ref_dist_full_3a>=ts_full_3b)/runs
pval_pc_3c <- sum(ref_dist_pc_3a>=ts_pc_3b)/runs
pval_noX_3c <- sum(ref_dist_pc_3a>= ts_pc_noX_3b)/runs

# plot(density_full_3a, 
#      main = "Full set test", 
#      xlab = "% different chrom", 
#      ylab = "density",
#      col = 6 )
# polygon(density_full_3a,
#         col = rgb(0,0,1,.2))
# lines(c(ts_full_3b, ts_full_3b),c(-0.05, 120), lwd = 3, col = "blue")
# text(.96, 100, paste("p = ",pval_full_3c), pos = 4, cex = 1)
# 
# plot(density_pc_3a, 
#      main = "protein coding only", 
#      xlab = "% different chrom", 
#      ylab = "density",
#      col = 9 )
# polygon(density_pc_3a,
#         col = rgb(0,.6,.4,.2))
# lines(c(ts_pc_3b, ts_pc_3b),c(-0.05, 120), lwd = 3, col = "blue")
# text(.90, 15, paste("p ~ ",pval_pc_3c), pos = 4, cex = 1)

ggplot(ref_dist_3a_df, aes(x = num_diff_full)) + 
  geom_histogram(aes(y =..density..), 
                 position = "identity", 
                 alpha = .5, color = "darkblue", 
                 fill = "lightblue") +
  geom_density( alpha = .6, color = "darkblue", size = 1, fill = "lightblue") +
  geom_vline(aes(xintercept = ts_full_3b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe a change in chromosome more than expected? (Full)", 
       x = "Avg. prop. of retrogene movement away from parental chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") + 
  geom_text(x = .957, y = 100,
            label = paste("p = ", pval_full_3c))

ggplot(ref_dist_3a_df, aes(x = num_diff_pc)) + 
  geom_bar(position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = ts_pc_3b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe a change in chromosome more than expected? (Protein coding only)", 
       x = "Avg. prop. of retrogene movement away from parental chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") +
  geom_text(x = .98, y = 170,
            label = paste("p = ", pval_pc_3c))

ggplot(ref_dist_3a_df, aes(x = num_diff_pc)) + 
  geom_bar(position = "identity", 
            alpha = .5, color = "darkgreen", 
            fill = "lightgreen") +
  geom_vline(aes(xintercept = ts_pc_noX_3b, color = "orange"), size = 1.2)+
  labs(title = "Do we observe a change in chromosome more than expected? \n (No 'ootX' retrogenes)", 
       x = "Avg. prop. of retrogene movement away from parental chromosome", 
       y = "Count") + 
  theme_classic() +
  theme(legend.position = "none") +
  geom_text(x = .98, y = 170,
            label = paste("p = ", pval_pc_3c))
```

Note that among protein coding genes, there seems to be a trend approaching significance, but not significant under the (lenient) threshold we set. However, keep in mind that opposing forces to increase or decrease linkage may be at work. 

# 4. Second hypothesis test: The retrogenes associated with each parental gene are not randomly distributed in the genome

This hypothesis is similar to the previous one, but instead of looking at individual pairs of retrocopies and parental genes, we look at parental genes and ALL associated retrocopies.

## a) Building reference distributions

(NOTE: This section needs work. Formula messed up.)

As before, we build a reference distribution both for the full set of retrocopies and for the set of retrogenes. We denote by \(\delta\) the simulated distance: 
$$
\delta = dist(a, x)
$$
This is the average distance between the parent and its offspring retrocopies. 

```{r, eval = FALSE}
#full set
# sim_dists_full_4a <- vector(mode = "numeric", length = runs)
# for(i in 1:runs){
#   totdist<- 0
#   for(j in 1:length(retrogenes_by_parentals)){
#     retro_chroms <- retrogenes_by_parentals[[j]]$retrochrom
#     if(length(retro_chroms>0)){
#       sim_rets <- sample(row.names(human_genome), 
#                          prob = human_genome$chrom.size, 
#                          size = length(retro_chroms), 
#                          replace = TRUE)
#       sim_ret_locs <- vector(mode = "numeric", length=length(retro_chroms))
#       tot_retro <- length(retro_chroms)
#       for(k in 1:length(sim_rets)){
#         sim_ret_locs[k] <- sample(1:human_genome$chrom.size[row.names(human_genome) == sim_rets[k]],
#                                  size = 1)
#       }
# 
#       
#       dists <- abs(retrogenes_by_parentals[[j]]$parentalloc - 
#                      sim_ret_locs[sim_rets==retrogenes_by_parentals[[j]]$parentalchrom])/linkage_max
#       dists <- ifelse(dists>.5, yes = .5, no = dists)
#       totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
#       totdist <- totdist + totdist_parental
#     }
#   }
#   sim_dists_full_4a[i] = totdist/length(retrogenes_final)
# }
# 
# density_full_4a <- density(sim_dists_full_4a)

#alternate density using recombination map
sim_dists_full_rec_4a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  avgdist<-0
  for(j in 1:length(retrogenes_by_parentals)){
    retro_chroms <- retrogenes_by_parentals[[j]]$retrochrom
    if(length(retro_chroms>0)){
      sim_rets <- sample(row.names(human_genome), 
                         prob = human_genome$chrom.size, 
                         size = length(retro_chroms), 
                         replace = TRUE)
      sim_ret_locs <- vector(mode = "numeric", length=length(retro_chroms))
      tot_retro <- length(retro_chroms)
      for(k in 1:length(sim_rets)){
        sim_ret_locs[k] <- sample(1:human_genome$chrom.size[row.names(human_genome) == sim_rets[k]],
                                 size = 1)
      }

      ret_locs_same <- sim_ret_locs[sim_rets == retrogenes_by_parentals[[j]]$parentalchrom]
      dists <- vector(mode = "numeric", length = length(ret_locs_same))
      if(length(ret_locs_same)){
        dists <- sapply(chr = retrogenes_by_parentals[[j]]$parentalchrom, 
                        loc1 = retrogenes_by_parentals[[j]]$parentalloc, 
                        X = ret_locs_same, 
                        FUN = find_dist)
        dists <- ifelse(dists>50, yes = .50, no = dists/100)
      }
      totdist <- (sum(dists) + (tot_retro-length(dists))*.5)
      avgdist <- avgdist + totdist/tot_retro
    }
  }
  sim_dists_full_rec_4a[i] = avgdist/length(retrogenes_by_parentals)
}
density_full_rec_4a <- density(sim_dists_full_rec_4a)

# #for protein coding only
# sim_dists_pc_4a <- vector(mode = "numeric", length = runs)
# for(i in 1:runs){
#   totdist<- 0
#   for(j in 1:length(retrogenes_by_parentals_pc)){
#     retro_chroms <- retrogenes_by_parentals_pc[[j]]$retrochrom
#     if(length(retro_chroms>0)){
#       sim_rets <- sample(row.names(human_genome), 
#                          prob = human_genome$chrom.size, 
#                          size = length(retro_chroms), 
#                          replace = TRUE)
#       sim_ret_locs <- vector(mode = "numeric", length=length(retro_chroms))
#       tot_retro <- length(retro_chroms)
#       for(k in 1:length(sim_rets)){
#         sim_ret_locs[k] = sample(1:human_genome$chrom.size[row.names(human_genome) == sim_rets[k]],
#                                  size = 1)
#       }
# 
#       
#       dists <- abs(retrogenes_by_parentals_pc[[j]]$parentalloc - 
#                      sim_ret_locs[sim_rets==retrogenes_by_parentals_pc[[j]]$parentalchrom])/linkage_max
#       dists <- ifelse(dists>.5, yes = .5, no = dists)
#       totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
#       totdist <- totdist + totdist_parental
#     }
#   }
#   sim_dists_pc_4a[i] = totdist/length(retrogenes_final_pc)
# }
# 
# density_pc_4a <- density(sim_dists_pc_4a)

#alternate density using recombination map for protein coding
sim_dists_pc_rec_4a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  avgdist<- 0
  for(j in 1:length(retrogenes_by_parentals_pc)){
    retro_chroms <- retrogenes_by_parentals_pc[[j]]$retrochrom
    if(length(retro_chroms>0)){
      sim_rets <- sample(row.names(human_genome), 
                         prob = human_genome$chrom.size, 
                         size = length(retro_chroms), 
                         replace = TRUE)
      sim_ret_locs <- vector(mode = "numeric", length=length(retro_chroms))
      tot_retro <- length(retro_chroms)
      for(k in 1:length(sim_rets)){
        sim_ret_locs[k] <- sample(1:human_genome$chrom.size[row.names(human_genome) == sim_rets[k]],
                                 size = 1)
      }

      ret_locs_same <- sim_ret_locs[sim_rets == retrogenes_by_parentals_pc[[j]]$parentalchrom]
      dists <- vector(mode = "numeric", length = length(ret_locs_same))
      if(length(ret_locs_same)){
        dists <- sapply(chr = retrogenes_by_parentals_pc[[j]]$parentalchrom, 
                        loc1 = retrogenes_by_parentals_pc[[j]]$parentalloc, 
                        X = ret_locs_same, 
                        FUN = find_dist)
        dists <- ifelse(dists>50, yes = .50, no = dists/100)
      }
      totdist <- (sum(dists) + (tot_retro-length(dists))*.5)
      avgdist <- avgdist+ totdist/tot_retro
    }
  }
  sim_dists_pc_rec_4a[i] = avgdist/length(retrogenes_by_parentals_pc)
}
density_pc_rec_4a <- density(sim_dists_pc_rec_4a)
# plot(density_full_4a)
# plot(density_full_rec_4a)
# plot(density_pc_4a)
# plot(density_pc_rec_4a)
```


## b) Calculating our test statistics

We calculate the above statistic, \(\delta\), using our data.

```{r}
#for full set
# totdist <- 0
# for(i in 1:length(retrogenes_by_parentals)){
#   retro_chroms <- retrogenes_by_parentals[[i]]$retrochrom
#   retro_locs <- retrogenes_by_parentals[[i]]$retroloc
#   tot_retro <- length(retro_chroms)
#   
#   dists <- abs(retrogenes_by_parentals[[i]]$parentalloc - retro_locs[retro_chroms == retrogenes_by_parentals[[i]]$parentalchrom])/linkage_max
#   dists <- ifelse(dists>.5, yes = .5, no = dists)
#   totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
#   totdist <- totdist + totdist_parental
# }
# ts_full_4b <- totdist/length(retrogenes_final)


#full set with recmap
totdist <- 0
for(i in 1:length(retrogenes_by_parentals)){
  retro_chroms <- retrogenes_by_parentals[[i]]$retrochrom
  retro_locs <- retrogenes_by_parentals[[i]]$retroloc
  tot_retro <- length(retro_chroms)
  
  ret_locs_same <- retro_locs[retro_chroms == retrogenes_by_parentals[[i]]$parentalchrom]
  dists <- vector(mode = "numeric", length = length(ret_locs_same))
  if(length(ret_locs_same)){
    dists <- sapply(chr = retrogenes_by_parentals[[i]]$parentalchrom, 
                    loc1 = retrogenes_by_parentals[[i]]$parentalloc, 
                    X = ret_locs_same, 
                    FUN = find_dist)
    dists <- ifelse(dists>50, yes = .50, no = dists/100)
  }
  totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
  totdist <- totdist + totdist_parental
}
ts_full_rec_4b <- totdist/length(retrogenes_final)

#pc
# totdist<- 0
# for(i in 1:length(retrogenes_by_parentals_pc)){
#   retro_chroms <- retrogenes_by_parentals_pc[[i]]$retrochrom
#   retro_locs <- retrogenes_by_parentals_pc[[i]]$retroloc
#   tot_retro <- length(retro_chroms)
#   
#   dists <- abs(retrogenes_by_parentals_pc[[i]]$parentalloc - retro_locs[retro_chroms == retrogenes_by_parentals_pc[[i]]$parentalchrom])/linkage_max
#   dists <- ifelse(dists>.5, yes = .5, no = dists)
#   totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
#   totdist <- totdist + totdist_parental
# }
# ts_pc_4b <- totdist/length(retrogenes_final_pc)

#pc with rec map
totdist <- 0
for(i in 1:length(retrogenes_by_parentals_pc)){
  retro_chroms <- retrogenes_by_parentals_pc[[i]]$retrochrom
  retro_locs <- retrogenes_by_parentals_pc[[i]]$retroloc
  tot_retro <- length(retro_chroms)
  
  ret_locs_same <- retro_locs[retro_chroms == retrogenes_by_parentals_pc[[i]]$parentalchrom]
  dists <- vector(mode = "numeric", length = length(ret_locs_same))
  if(length(ret_locs_same)){
    dists <- sapply(chr = retrogenes_by_parentals_pc[[i]]$parentalchrom, 
                    loc1 = retrogenes_by_parentals_pc[[i]]$parentalloc, 
                    X = ret_locs_same, 
                    FUN = find_dist)
    dists <- ifelse(dists>50, yes = .50, no = dists/100)
  }
  totdist_parental <- (sum(dists) + (tot_retro-length(dists))*.5)
  totdist <- totdist + totdist_parental
}
ts_pc_rec_4b <- totdist/length(retrogenes_final_pc)
```

## c) Test hypothesis

Using our test statistics, we can compare to reference and obtain p-values as before.

```{r}
# pval_full_4c <- sum(sim_dists_full_4a>=ts_full_rec_4b)/runs
pval_full_rec_4c <- sum(sim_dists_full_rec_4a<=ts_full_rec_4b)/runs
# pval_pc_4c <- sum(sim_dists_pc_4a>=ts_pc_4b)/runs
pval_pc_rec_4c <- sum(sim_dists_pc_rec_4a<=ts_pc_rec_4b)/runs


# plot(density_full_4a, 
#      xlim = c(.492, .5),
#      main = "Full set test", 
#      xlab = "average distance", 
#      ylab = "density",
#      col = 6 )
# polygon(density_full_4a,
#         col = rgb(0,0,1,.2))
# lines(c(ts_full_4b, ts_full_4b),c(-0.05, 400), lwd = 3, col = "blue")
# text(.494, 350, paste("p = ",pval_full_4c), pos = 4, cex = 1)

plot(density_full_rec_4a, 
     main = "Are retrocopies of a parental gene randomly distributed in the genome?", 
     xlab = "Average genetic distance between parental gene and retrocopies", 
     ylab = "Count",
     col = 6 )
polygon(density_full_rec_4a,
        col = rgb(0,0,1,.2))
lines(c(ts_full_rec_4b, ts_full_rec_4b),c(-0.05, 500), lwd = 3, col = "blue")
text(.494, 350, paste("p ~ ",pval_full_rec_4c), pos = 4, cex = 1)
# 
# plot(density_pc_4a, 
#      main = "protein coding only", 
#      xlab = "average distance", 
#      ylab = "density",
#      col = 9 )
# polygon(density_pc_4a,
#         col = rgb(0,.6,.4,.2))
# lines(c(ts_pc_4b, ts_pc_4b),c(-0.05, 150), lwd = 3, col = "blue")
# text(.485, 130, paste("p ~ ",pval_pc_4c), pos = 4, cex = 1)

plot(density_pc_rec_4a, 
     main = "Are retrogenes of a parental gene randomly distributed in the genome?", 
     xlab = "Average genetic distance between parental gene and retrogenes", 
     ylab = "Count",
     col = 9 )
polygon(density_pc_rec_4a,
        col = rgb(0,.6,.4,.2))
lines(c(ts_pc_rec_4b, ts_pc_rec_4b),c(-0.05, 150), lwd = 3, col = "blue")
text(.485, 80, paste("p ~ ",pval_pc_rec_4c), pos = 4, cex = 1)
```


# 5. Hypothesis test 3: Retrogenes are not randomly distributed with respect to their nearest network partner

This hypothesis incorporates information that we have about network partners for each of the parental genes. We formulate the null that retrogenes are randomly dispersed in the genome without regards to proximity to network partners. 

## a) Constructing reference distributions

For this hypothesis, we construct reference distributions around a statistic
$$\eta = \min\{dist(a,x): x\in E\}$$
where \(E\) is the set of all network partners of a retrocopy, including parental genes and \(a\) is the associated retrocopy.

Hence, this statistic denotes the minimum distance to a network partner for a retrocopy. We construct 3 null distributions; 

1) \(E\) with respect to all retrocopies, and \(a\) distributed randomly in the genome.
2) \(E\) with respect to retrogenes only, and \(a\) distributed randomly in the genome.
3) \(E\) with respect to all retrocopies, and \(a\) randomly drawn from all retrocopies.

```{r, eval = FALSE}
# ref_dist_full_5a <- vector(mode = "numeric", length = runs)
# for(i in 1:runs){
#   delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final))
#   for(j in 1:length(retrogenes_final)){
#     par_chrom <- retrogenes_final[[j]][[1]]$parentalchrom 
#     par_loc <- retrogenes_final[[j]][[1]]$parentalloc
#     part_chroms <- retrogenes_final[[j]][[1]]$partnerchroms
#     part_locs <- retrogenes_final[[j]][[1]]$partnerlocs
#     
#     all_chroms <- c(par_chrom, part_chroms)
#     all_locs <- c(par_loc, part_locs)
#     
#     sim_ret_chrom <- sample(row.names(human_genome), 
#                             prob = human_genome$chrom.size,
#                             size = 1)
#     sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom], size = 1)
#     mindist <- ifelse(sim_ret_chrom%in% all_chroms,
#                       yes =  min(abs(all_locs[sim_ret_chrom == all_chroms] - sim_ret_loc))/linkage_max,
#                       no =.5)
#     
#     delta_dists_sim[j] <- mindist
#   }
#   ref_dist_full_5a[i] <- mean(delta_dists_sim)
# }
# density_full_5a <- density(ref_dist_full_5a)

#using recombination map
ref_dist_rec_5a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final))
  for(j in 1:length(retrogenes_final)){
    par_chrom <- retrogenes_final[[j]][[1]]$parentalchrom 
    par_loc <- retrogenes_final[[j]][[1]]$parentalloc
    part_chroms <- retrogenes_final[[j]][[1]]$partnerchroms
    part_locs <- retrogenes_final[[j]][[1]]$partnerlocs
    
    all_chroms <- c(par_chrom, part_chroms)
    all_locs <- c(par_loc, part_locs)
    
    sim_ret_chrom <- sample(row.names(human_genome), 
                            prob = human_genome$chrom.size,
                            size = 1)
    sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom], size = 1)
    all_chrom_same <- all_locs[all_chroms == sim_ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = sim_ret_chrom, 
                      loc1 = sim_ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
    delta_dists_sim[j] <- mindist
  }
  ref_dist_rec_5a[i] <- mean(delta_dists_sim)
}
density_full_rec_5a <- density(ref_dist_rec_5a)

##retrogenes only
# ref_dist_pc_5a <- vector(mode = "numeric", length = runs)
# for(i in 1:runs){
#   delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final_pc))
#   for(j in 1:length(retrogenes_final_pc)){
#     par_chrom <- retrogenes_final_pc[[j]][[1]]$parentalchrom 
#     par_loc <- retrogenes_final_pc[[j]][[1]]$parentalloc
#     part_chroms <- retrogenes_final_pc[[j]][[1]]$partnerchroms
#     part_locs <- retrogenes_final_pc[[j]][[1]]$partnerlocs
#     
#     all_chroms <- c(par_chrom, part_chroms)
#     all_locs <- c(par_loc, part_locs)
#     
#     sim_ret_chrom <- sample(row.names(human_genome), 
#                             prob = human_genome$chrom.size,
#                             size = 1)
#     sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom],
#                           size = 1)
#     
#     mindist <- ifelse(sim_ret_chrom %in% all_chroms,
#                       yes = min(abs(all_locs[sim_ret_chrom == all_chroms] - sim_ret_loc))/linkage_max,
#                       no = .5)
#     
#     delta_dists_sim[j] <- mindist
#   }
#   ref_dist_pc_5a[i] <- mean(delta_dists_sim)
# }
# density_pc_5a <- density(ref_dist_pc_5a)


#using recombination map, retrogenes only
ref_dist_pc_rec_5a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final_pc))
  for(j in 1:length(retrogenes_final_pc)){
    par_chrom <- retrogenes_final_pc[[j]][[1]]$parentalchrom 
    par_loc <- retrogenes_final_pc[[j]][[1]]$parentalloc
    part_chroms <- retrogenes_final_pc[[j]][[1]]$partnerchroms
    part_locs <- retrogenes_final_pc[[j]][[1]]$partnerlocs
    
    all_chroms <- c(par_chrom, part_chroms)
    all_locs <- c(par_loc, part_locs)
    
    sim_ret_chrom <- sample(row.names(human_genome), 
                            prob = human_genome$chrom.size,
                            size = 1)
    sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom], size = 1)
    all_chrom_same <- all_locs[all_chroms == sim_ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = sim_ret_chrom, 
                      loc1 = sim_ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
    delta_dists_sim[j] <- mindist
  }
  ref_dist_pc_rec_5a[i] <- mean(delta_dists_sim)
}
density_pc_rec_5a <- density(ref_dist_pc_rec_5a)

#with all retrocopies as null
# ref_dist_mixed_5a <- vector(mode = "numeric", length = runs)
# for(i in 1:runs){
#   delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final_pc))
#   for(j in 1:length(retrogenes_final_pc)){
#     k <- sample(1:length(retrogenes_final), size = 1)
#     par_chrom <- retrogenes_final[[k]][[1]]$parentalchrom 
#     par_loc <- retrogenes_final[[k]][[1]]$parentalloc
#     part_chroms <- retrogenes_final[[k]][[1]]$partnerchroms
#     part_locs <- retrogenes_final[[k]][[1]]$partnerlocs
#     
#     all_chroms <- c(par_chrom, part_chroms)
#     all_locs <- c(par_loc, part_locs)
#     
#     sim_ret_chrom <- sample(row.names(human_genome), 
#                             prob = human_genome$chrom.size,
#                             size = 1)
#     sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom],
#                           size = 1)
#     
#     mindist <- ifelse(sim_ret_chrom %in% all_chroms,
#                       yes = min(abs(all_locs[sim_ret_chrom == all_chroms] - sim_ret_loc))/linkage_max,
#                       no = .5)
#     
#     delta_dists_sim[j] <- mindist
#   }
#   ref_dist_mixed_5a[i] <- mean(delta_dists_sim)
# }
# density_mixed_5a <- density(ref_dist_mixed_5a)

#rec map mixed
ref_dist_mixed_rec_5a <- vector(mode = "numeric", length = runs)
for(i in 1:runs){
  delta_dists_sim <- vector(mode = "numeric", length = length(retrogenes_final_pc))
  for(j in 1:length(retrogenes_final_pc)){
    par_chrom <- retrogenes_final[[j]][[1]]$parentalchrom 
    par_loc <- retrogenes_final[[j]][[1]]$parentalloc
    part_chroms <- retrogenes_final[[j]][[1]]$partnerchroms
    part_locs <- retrogenes_final[[j]][[1]]$partnerlocs
    
    all_chroms <- c(par_chrom, part_chroms)
    all_locs <- c(par_loc, part_locs)
    
    sim_ret_chrom <- sample(row.names(human_genome), 
                            prob = human_genome$chrom.size,
                            size = 1)
    sim_ret_loc <- sample(1:human_genome_h$chrom.size[row.names(human_genome) == sim_ret_chrom], size = 1)
    all_chrom_same <- all_locs[all_chroms == sim_ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = sim_ret_chrom, 
                      loc1 = sim_ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
    delta_dists_sim[j] <- mindist
  }
  ref_dist_mixed_rec_5a[i] <- mean(delta_dists_sim)
}
density_rec_mixed_5a <- density(ref_dist_mixed_rec_5a)


# plot(density_full_5a)
# plot(density_pc_5a)
# plot(density_mixed_5a)
# hist(ref_dist_rec_5a)
# hist(ref_dist_pc_rec_5a)
# hist(ref_dist_pc_5a)
# hist(ref_dist_mixed_5a)
# hist(ref_dist_mixed_rec_5a)
```


## b) Calculating test statistics

We calculate the test statistic \(\eta = \frac{\sum^{all\,x}min\{ dist(x,y): y\in A\}}{n}\) where \(x\) is the retrogene and \(A\) is the union of the parental gene and the set of network genes.

```{r}
dists_tot <- vector(mode = "numeric", length = length(retrogenes_final))
for(i in 1:length(retrogenes_final)){
    par_chrom <- retrogenes_final[[i]][[1]]$parentalchrom 
    par_loc <- retrogenes_final[[i]][[1]]$parentalloc
    part_chroms <- retrogenes_final[[i]][[1]]$partnerchroms
    part_locs <- retrogenes_final[[i]][[1]]$partnerlocs
    
    all_chroms <- c(par_chrom, part_chroms)
    all_locs <- c(par_loc, part_locs)
    
    ret_chrom <- retrogenes_final[[i]][[1]]$retrochrom
    ret_loc <- retrogenes_final[[i]][[1]]$retroloc
    all_chrom_same <- all_locs[all_chroms == ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = ret_chrom, 
                      loc1 = ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
    dists_tot[i] <- mindist
}
ts_full_5b <- mean(dists_tot)

dists_pc <- vector(mode = "numeric", length = length(retrogenes_final_pc))
for(i in 1:length(retrogenes_final_pc)){
    par_chrom <- retrogenes_final_pc[[i]][[1]]$parentalchrom 
    par_loc <- retrogenes_final_pc[[i]][[1]]$parentalloc
    part_chroms <- retrogenes_final_pc[[i]][[1]]$partnerchroms
    part_locs <- retrogenes_final_pc[[i]][[1]]$partnerlocs
    
    all_chroms <- c(par_chrom, part_chroms)
    all_locs <- c(par_loc, part_locs)
    
    ret_chrom <- retrogenes_final_pc[[i]][[1]]$retrochrom
    ret_loc <- retrogenes_final_pc[[i]][[1]]$retroloc
    all_chrom_same <- all_locs[all_chroms == ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = ret_chrom, 
                      loc1 = ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
    dists_pc[i] <- mindist
}
ts_pc_5b <- mean(dists_pc)

dists_mixed <- vector(mode = "numeric", length = length(retrogenes_final_pc))
for(i in 1:length(retrogenes_final_pc)){
  par_chrom <- retrogenes_final_pc[[i]][[1]]$parentalchrom 
  par_loc <- retrogenes_final_pc[[i]][[1]]$parentalloc
  part_chroms <- retrogenes_final_pc[[i]][[1]]$partnerchroms
  part_locs <- retrogenes_final_pc[[i]][[1]]$partnerlocs
  
  all_chroms <- c(par_chrom, part_chroms)
  all_locs <- c(par_loc, part_locs)
    
  ret_chrom <- retrogenes_final_pc[[i]][[1]]$retrochrom
  ret_loc <- retrogenes_final_pc[[i]][[1]]$retroloc
    all_chrom_same <- all_locs[all_chroms == ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = ret_chrom, 
                      loc1 = ret_loc, 
                      X = all_chrom_same, 
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
  dists_mixed[i] <- mindist  
}
ts_mixed_5b<- mean(dists_mixed)


noX_indices <- c()
for(i in 1:length(retrogenes_final_pc)){
  if(retrogenes_final_pc[[i]][[1]]$parentalchrom == "X"){
    noX_indices <- c(noX_indices, i)
  }
}
retrogenes_final_pc_noX <- retrogenes_final_pc[-noX_indices]
dists_mixed_noX <- vector(mode = "numeric", length = length(retrogenes_final_pc_noX))
for(i in 1:length(retrogenes_final_pc_noX)){
  par_chrom <- retrogenes_final_pc_noX[[i]][[1]]$parentalchrom
  par_loc <- retrogenes_final_pc_noX[[i]][[1]]$parentalloc
  part_chroms <- retrogenes_final_pc_noX[[i]][[1]]$partnerchroms
  part_locs <- retrogenes_final_pc_noX[[i]][[1]]$partnerlocs

  all_chroms <- c(par_chrom, part_chroms)
  all_locs <- c(par_loc, part_locs)

  ret_chrom <- retrogenes_final_pc_noX[[i]][[1]]$retrochrom
  ret_loc <- retrogenes_final_pc_noX[[i]][[1]]$retroloc
    all_chrom_same <- all_locs[all_chroms == ret_chrom]
    dists <- vector(mode = "numeric", length = length(all_chrom_same))
    if(length(all_chrom_same)){
      dists <- sapply(chr = ret_chrom,
                      loc1 = ret_loc,
                      X = all_chrom_same,
                      FUN = find_dist)
      dists <- ifelse(dists>50, yes = .50, no = dists/100)
      mindist <- min(dists)
    }else{
      mindist <- .5
    }
  dists_mixed_noX[i] <- mindist
}
ts_mixed_noX_5b<- mean(dists_mixed_noX)

```

## c) Test hypothesis

Using our test statistics, we can compare to reference and obtain p-values as before.

```{r}
pval_full_5c <- sum(ref_dist_rec_5a>=ts_full_5b)/runs
pval_pc_5c <- sum(ref_dist_pc_rec_5a>=ts_pc_5b)/runs
pval_mixed_5c <- sum(ref_dist_mixed_rec_5a <= ts_pc_5b)/runs
pval_mixed_noX_5c <- sum(ref_dist_mixed_rec_5a <= ts_mixed_noX_5b)/runs


plot(density_full_rec_5a, 
     xlim = c(.415, .435),
     main = "Are retrocopies randomly distributed with respect \n to their nearest network partner?", 
     xlab = "Mean minimum distance from nearest network partner", 
     ylab = "Count",
     col = 6 )
polygon(density_full_rec_5a,
        col = rgb(0,0,1,.2))
lines(c(ts_full_5b, ts_full_5b),c(-0.05, 200), lwd = 3, col = "blue")
text(.42, 130, paste("p = ",pval_full_5c), pos = 4, cex = 1)

plot(density_pc_rec_5a, 
     main = "Are retrogenes randomly distributed with respect \n to their nearest network partner?", 
     xlab = "Mean minimum distance from nearest network partner", 
     ylab = "Count",
     col = 9 )
polygon(density_pc_rec_5a,
        col = rgb(0,.6,.4,.2))
lines(c(ts_pc_5b, ts_pc_5b),c(-0.05, 30), lwd = 3, col = "blue")
text(.38, 15, paste("p ~ ",pval_pc_5c), pos = 4, cex = 1)

plot(density_rec_mixed_5a, 
     main = "using retrocopies as null", 
     xlab = "mean minimum distance", 
     ylab = "density",
     col = 9 )
polygon(density_rec_mixed_5a,
        col = rgb(0,.6,.4,.2))
lines(c(ts_pc_5b, ts_pc_5b),c(-0.05, 100), lwd = 3, col = "blue")
text(.425, 10, paste("p ~ ",pval_mixed_5c), pos = 4, cex = 1)

plot(density_rec_mixed_5a, 
     main = "average minimum distance from nearest network partner", 
     xlab = "mean minimum distance", 
     ylab = "density",
     col = 9 )
polygon(density_rec_mixed_5a,
        col = rgb(0,.6,.4,.2))
lines(c(ts_mixed_noX_5b, ts_mixed_noX_5b),c(-0.05, 100), lwd = 3, col = "blue")
text(.410, 10, paste("p ~ ",pval_mixed_noX_5c), pos = 4, cex = 1)
```